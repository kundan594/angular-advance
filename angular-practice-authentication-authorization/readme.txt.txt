
Transcript links
The Importance of Using a BFF
What You Should Know Beforehand
A radical change happened recently that completely changed the best practices around Angular authentication. You should know the ins and outs as soon as possible. My name is Roland Guijt, and welcome to the course Angular in Practice: Authentication and Authorization. As the name implies, this will be a fast‑paced, practical approach to authentication and authorization with Angular, where I assume familiarity with both Angular and OAuth, as well as OpenID Connect. If you feel you're not up to speed on the latter, please watch my other authentication and authorization Angular course where that knowledge is not required and come back later to gain a new perspective on what you have learned there.

Anti-patterns
We start by covering a number of anti‑patterns, which will include the reasons why they shouldn't be used. Just to make sure we're on the same page, I use both the terms SPA and Angular application interchangeably throughout the course. SPA stands for single‑page application, and that's what the Angular application is. It downloads all assets on the first request, after which all UI logic for the application executes in the browser. Here's an Angular application running in the browser together with an API on the server it uses. Developers have created a login page in the SPA where users can enter credentials, and the credentials are checked by the SPA as well. That means there has to be a list somewhere of usernames and passwords accessible from JavaScript. To protect the API, a fixed API key is used that is stored on the Angular side as well. The reasoning behind that is that only the SPA can access the API since nothing else knows that secret. There are a number of things fundamentally wrong with this approach, but the main problem is that the browser can't be trusted with secrets like the table with usernames and passwords and the API key. The reason is that everything sent to the browser is very easy to read and manipulate. Users only have to press F12 in the browser, and they can easily find the secrets, and non‑users also can get to the secrets relatively easily by using common attacks like cross‑site scripting and cross‑site request forgery. Encryption doesn't work because the encryption key must be stored somewhere within the browser's reach, too. Further downsides are that the API key is static. It could be rotated manually, but in practice that rarely happens. Because of that, when it gets stolen, attackers have unlimited access to the API. Also, the API doesn't know who the user is, so it can't do any user‑specific authorization. The second anti‑pattern involves an identity provider using OAuth. There's still a login page in the Angular application, but now the user's credentials are sent to the identity provider using a flow called resource owner password credentials flow. The credentials are verified, after which the SPA gets an access token that is then sent to the API as an alternative for the API key. This is slightly better. The Angular application doesn't own the user data now, and where the API key had an infinite lifetime, the lifespan of the access token is limited. Also, the API now knows who the user is because the subject ID claim is in the access token when OpenID Connect is used. There are still big problems, though. The access token is still sent to the browser, and the access token, too, is a secret, a very important one that grants access to data probably owned by the user. And this, too, is a secret the browser can't keep. Also, the user's secret should only be known at the level of the identity provider. And now it is exposed in an app that is vulnerable to all kinds of browser attacks. Further downsides that also apply to the previous anti‑pattern are that using a federation with other identity providers, such as Google, is not possible and that the login workflow is now on the application side. Any changes would require the redistribution of the new build of the application. Also, this pattern limits user authentication to just passwords where often MFA or passkey support is desirable. The third anti‑pattern tries to solve problems using a JavaScript library that supports OpenID Connect using either the implicit or the authorization code flow. Now when the Angular application detects that the user has not signed in yet, it will redirect to the identity provider where users can enter their credentials. When the login process completes, a callback request back to the Angular application will take place. That will contain the tokens. When using OpenID Connect, there will not only be an access token that can be used to call the API, but also an identity token that can be validated by the Angular application after which the claims inside can be read. Our application will now know for sure that the user successfully logged in while having the user's information. In this scenario, the user enters credentials on the identity provider instead of the Angular application. That's good. But the browser still gets the access token that can't be kept safely. It doesn't really matter if implicit flow or authorization code flow is used here, the token will always end up in the browser. And we've just talked about the access token until now, which is already a high‑value target for attackers. Things get even worse when refresh tokens are involved. These potentially grant perpetual access to the resources unless the attack is detected, which might be hard to do.

Authorization Code Flow
Authorization code flow was originally designed for web applications where the HTML is rendered on a server application using the MVC pattern using Express or ASP.NET, for example. Its most important purpose is to keep the access token out of the browser's reach. Instead of the tokens, a code which is a random string, is returned in the callback when logging completes. And the browser's job is to send the code to the server, and then the server application uses it to exchange it for the tokens at the token endpoint on the identity provider. These could be the identity access and refresh tokens, but since the identity token doesn't unlock any resources, there are also variations of this flow that send that token directly to the browser. The request that exchanges the code for the tokens is a server‑to‑server request, not a redirect in the browser. So that request isn't visible to the browser. It is called the backchannel request. While doing the request, the client has to authenticate using its client secret. This secret is defined for the application of the identity provider and it has nothing to do with a user. The browser doesn't know these credentials. They are safely stored on the server, and that's why it's safe to send the browser the code. It is useless without the client credentials. You could sort of make this work with just an Angular application using a client library supporting authorization code flow. The code could be returned from the callback, and then the Angular application itself could exchange the code for tokens. You could use a client's secret for that, but that wouldn't make much sense because the browser can't keep the secret. So in the past, client secrets were often disabled, which of course results in the fact that now when the code gets stolen, it can be exchanged for tokens by anyone. Hopefully you now see that no matter what we do there is no way to do this in a safe manner with just a SPA with just the Angular application. The solution to this is to create a place where secrets can be safely kept, and that place is on a server. We need a backend for the frontend. Now I understand you are probably a passionate frontend developer, and you don't like the idea of having to maintain a backend for authentication. But unfortunately, there's no other possibility to play this safe.

Backend For Frontend (BFF)
From the OAuth 2.1 specification onwards, implicit flow is removed completely, and using the backend for frontend, or BFF pattern, is the official recommendation when using SPAs. So how does this work with our Angular applications? In this picture, now the Angular application has a backend dedicated to our SPA, the BFF, which will handle the complexities around authentication, and maybe, more importantly, is able to keep secrets. I've left out the API for now, but it will return later. When the Angular application wants to authenticate when the user presses the Login button, for example, it will simply send a request to the /bff/login endpoint on the BFF. This URL is just an example. It can be anything you want. How authentication is handled is determined by the BFF. One option would be to not use OpenID Connect at all. The BFF could show a login page, retrieve user information, and set a session cookie. Using the cookie, protected endpoints, like API endpoints on the BFF, can now be accessed by the SPA. To access other external APIs, an access token would be required, though. And giving every BFF its own authentication mechanism is probably not desirable. So here OpenID Connect comes in again. The BFF can also be made the client of an authentication provider, and it can initiate the authentication process using authorization code flow. The user logs in using the login page on the identity provider, and when that is successful, the code is sent to the browser and made available to the BFF. Now the BFF exchanges the code for the token. And this request is a true backchannel request. The BFF server application is talking directly to the identity provider without the browser knowing about it. As soon as the tokens arrive, the BFF will validate and read the identity token that contains the user's claims and set the session cookie in the browser that can contain any of these claims. The BFF is also free to add extras. When the cookie is set, the identity token is discarded, but the other tokens, the access and refresh tokens, are either kept on the BFF for later use or added to the encrypted session cookie. The key to decrypt the cookie is only known at the BFF level, so its contents is useless to anyone that tries to read the cookie. Besides, the cookie has the HTTP only flag, so it can't be accessed from JavaScript in the browser, preventing cross‑site scripting attacks.

BFF Endpoints
Apart from the login endpoint, the BFF typically has other endpoints, such as the logout endpoint that deletes the session cookie and also redirects to the end session endpoint on the identity provider when using OpenID Connect. That is needed because the identity provider set a session cookie as well, the single sign‑on cookie. It has to be deleted. Besides that, frontend or backchannel logout might need to be triggered, giving other clients sharing the same session the opportunity to end their session. Another endpoint is the user endpoint. The BFF session cookie doesn't help our Angular app to know who the user is. It is encrypted and it isn't accessible via JavaScript. Because of that, to know if users are logged in and if so, what their claims are, the Angular application has to call an endpoint on the BFF. Again, it can be any URL, but /bff/user makes sense. That endpoint, of course, can only be accessed with a valid session cookie, which can then be read after which the user's claims are returned. When the user isn't authenticated, this endpoint will return the status code 401 Unauthorized. That's how our SPA knows the user didn't log in yet. Now what if the Angular application needs to access an external API that is potentially shared with many other applications? It will need an access token to do that, but it doesn't have one. The BFF provides endpoints for that that, of course, also require a valid session cookie. Here the BFF is configured to forward requests that start with /api to an external API while taking care of attaching the access token. And the BFF will make sure the result from the API request will be returned to the Angular application. Besides endpoints that facilitate the use of session and external APIs, API endpoints can also be created on the BFF itself, as long as they are only used by the SPA. They can only be used by the SPA because these endpoints require a valid session cookie instead of an access token, and that session cookie should be a SameSite cookie.

SameSite Session Cookies and Reverse Proxy
The SameSite cookie has to be used as the session cookie to protect against cross‑site request forgery, or CSRF. That means the cookie will only be included in requests that came from the SameSite that originally set the cookie. Setting the SameSite flag on the session cookie will make sure the cookie can only be used by our SPA, not by any other web app or site. In this example, the BFF and the Angular application run on a different site. When the user logs in, the browser will receive the cookie while it is showing the login page on the URL of the BFF. When login completes, the browser will be redirected to the Angular application on the other domain. Now when the Angular application wants to do a request to the BFF, it can do that, but the cookie won't be sent by the browser, and that is for good reason. When other sites were able to do this, all kinds of attack factors are opening up, for example, using exploits like phishing. So to solve this, we have to make sure both the BFF and the Angular application run on the SameSite. So, what are the possibilities? Well, we could just let the BFF host the Angular application by putting all Angular files from a production build on the BFF while enabling static files hosting. In most cases, however, having the SPA and the BFF as one deployable unit is inconvenient. It is way more practical to have them in separate projects that can be individually deployed because they are also developed separately, and that will often mean they will run on different sites. In that case, a web server that acts as a reverse proxy can be used, which is responsible for routing requests to, for example, /bff to the BFF and all other requests to the SPA. Using this method from the perspective of the browser, the SPA and the BFF will run on the SameSite. With the proxy running on myproxy.com, when the user logs in, the browser will redirect to, for example, myproxy.com/bff, and the proxy will take care of forwarding the request to the site the BFF runs on. When the redirect occurs, the browser now not redirects to the site of the Angular application, but again to a proxy URL. For example, /ng. From the browser's perspective, this is the SameSite. So now SameSite cookies are sent along when the Angular application sends a request to the BFF via the proxy. Also keep in mind that the SameSite cookie flag has two modes. Many server‑side frameworks use lacks as default, which makes an exception for GET requests. So the browser will send a cookie when any GET requests from any site occurs. If possible, it's best to set this to strict so that there are no exceptions. Now that we covered most concepts, the next module will make using a BFF more tangible.

Setting Up a BFF with OAuth2 and OpenID Connect
The BFF Usecase
We're diving into the code in this module. I'll show you how to set up an Angular application that works with the BFF with an approach using ASP.NET core as the backend technology. It is just an example. There are many other ways using other platforms to do it. As different platforms tend to function in similar ways, you should be able to apply the concepts shown here to any backend platform. If you want the code I'm about to show you, please clone or download it from here. And if you don't have it installed yet, please get the .NET 9 SDK here and install it. Also, make sure you have an up‑to‑date Node.js installed. If not, please upgrade because the Angular project won't run. You can find the latest version on Nodejs.org. Then in the Angular SSR directory of the downloaded code, get the necessary NPM packages by typing npm install. After that, you're ready to run the project. Switch to the Angular BFF directory and type dotnet run. Now a browser window should open showing a message that the SPA is loading, after which the landing page shows. If that doesn't happen, hold down Ctrl or Command and click on the URL. After pressing log in, a login page is displayed, which is not part of the Angular application. In this initial basic BFF setup, the page is rendered by the BFF. Logging in can be done with user name Bob with password Bob. The BFF will now check the credentials and set the session cookie, after which it redirects to the SPA, which now detects there is a valid session cookie by calling the user endpoint. It then attaches the cookie to a request to the BFF. It has an API endpoint that requires the cookie. It returns the house data that is rendered in this house list component. A house can be added to the list with the Add button, and when a house is clicked, a request to another endpoint on the BFF takes place, getting the house details that are also rendered by our SPA. The user's claims can also be shown. This page is rendered by Angular using the data from the user endpoint coming from the BFF. That endpoint simply decrypts the claims in the session cookie and returns them. And when the logout button is pressed, request to the logout endpoint of the BFF takes place. It will delete the session cookie and redirect it back to the SPA, which will now detect there's no authenticated user Because it'll get back an HTTP status code 401 and no claims are returned.

Angular Authentication Mechanics
The code shown in this course is based on the work done by Marco Cabrera. It was kindly contributed to the Duende samples library. Thank you, Marco. I'm using JetBrain's writer here to show and run the code, but any IDE or editor will do. The authentication heart of the Angular application is the AuthService that does the session management for the user. It has an internal Observable calls Session, which defaults to null. The Observable is of type Session, which is a Claim array, where Claim contains the type and value properties. The Observable will get a value when getSession is called, which does an HTTP request to the user endpoint of the BFF fetching the claims. This only works when there's a valid session cookie. If there isn't, an HTTP status code 401 will be returned, and then it will get the value ANONYMOUS, which is null. ShareReplay here is an RxJS function that makes sure that if there are multiple subscribers to the Observable, only the first subscriber will trigger the HTTP request. The rest will get the latest value because the value for cache size is 1. Then the function returns the Observable. The values for the two used variables, ANONYMOUS and CACHE_SIZE, are found on top of the file. GetSession gets called here. Notice that it is deferred, meaning it will only be called when rendering is done. The Observable return is converted to a signal that too has an initial value of null. A bunch of computed signals are defined that all use a signal. Because of that, they will automatically update when the underlying value of the signal changes. IsAuthenticated, and isAnonymous check if there is a non‑null session. Username finds the claim with the type name and returns its value, and logout_url also looks for a claim. I'll explain why later. In the current configuration, it will default to /bff/logout. In the nav‑menu component shown as the page header, the AuthService object is injected, and the needed signal references are copied. In the HTML, we see that isAuthenticated is called. If users are authenticated, the show user‑session link is shown, and if not, a simple link to the login endpoint of the BFF. And that is basically everything the Angular application has to know to log in, the location of the login endpoint. For the rest, there's no configuration needed. The same goes for logout. All it does is call the logout endpoint on the BFF. In the component that shows the claims, a similar pattern is used with the AuthService. In addition, there is a signal called claims that is equal to the session unless it is null. Then it will be an empty array. In the HTML, the claims in that array are rendered in a table.

BFF Structure
The project that contains the BFF is an ASP.NET Core project. Just like many other backend platforms, it uses dependency injection and a middleware pipeline, which are configured in the file Program.cs. Here the services for RazorPages, an ASP.NET Core technique to create HTML pages that can contain C#, and the services for BFF are added. This extension method is added by a library called Duende BFF that makes coding a BFF easy while covering all security aspects. Please note that Duende BFF requires a license for bigger companies, and full disclosure, I'm a Duende contractor, but no need to use this product specifically. Especially with a BFF cookie‑only scenario like this, it is perfectly feasible to write your own BFF without the help of libraries. I just want to keep the code as readable as possible without going into .NET details too much, knowing many viewers of this course will probably use other backend platforms. Authentication and ASP.NET Core is configured with a call to add authentication. Multiple authentication methods can be added, which are called schemes. We're adding two here, cookie and OpenID Connect, but right now we only use the cookie scheme. When the cookie scheme detects that the user needs to log in, its default behavior is to redirect to /account/login. I've created a page with a login form on that path. When the form is submitted, a very simple username and password check takes place, after which a collection of claims is constructed. A name Claim with a value Bob and a subject ID claim with a value 1. Then a ClaimsIdentity is constructed using the claims, and that is used to sign the user in. Since only the cookie scheme is active here, this means that the session cookie is created. Finally, we redirect to root, which will reload the Angular application. Let's switch back to the code that configures the cookie scheme. The cookie name starts with __Host. With this prefix, the browser will enforce strict security requirements on the cookie that prevent the cookie from being overwritten by insecure sources because it is not valid for subdomains. Please look here for more information about that. We also see that the cookie is the SameSite cookie using the strict mode. The default in ASP.NET Core is lax. Further down, there's a BFF middleware being plugged into the pipeline that prevents CSRF. You'll see how that works later in the module. And the BFF management endpoints, such as the login, logout, and user endpoints, are being added to the routing table. The next line of code adds API endpoints to the BFF. They respond to requests to /api/houses. RequireAuthorization means in this context that they require a valid session cookie, and they are marked as BFF endpoints to include them in the before‑mentioned CSRF protection. The implementation of the various endpoints can be found in the file HousesEndpointGroup.cs. After the API endpoints are configured in Program.cs, a call to MapFallbackToFile ensures that index.html is loaded when no other routes that were configured in the pipeline match the URL the browser requests. Index.html is the entry point of the Angular application, so this line of code is the reason we just have to start the BFF project to automatically load the Angular application. And it is also the reason the SameSite cookie works, since both the BFF and the Angular application are now running on the same site. There is, however, a bit more plumbing needed to get this to work.

Proxies
In the Program.cs file of the BFF, we saw that the Angular application is served by simply rendering its index.html. However, it does have its own project, which is referenced by the BFF project. So the Angular application has to be built before index.html, Angular's entrypoint can be loaded. Ideally, it should start in the same way it is started when developing the application separately, so we can debug and keep all functionality that makes developing in Angular great, such as the feature that automatically refreshes the browser when changes are made in the source code. Microsoft has a solution for that with a special project file with the .esproj extension. In that file there's a command to start serving a developer build configured. And the location of the output files, so it knows where to find the entrypoint. If you're not using ASP.NET and a similar feature is not available on your platform, you'll have to manually start both the BFF and the Angular application separately. To be able to use SameSite cookies, there's also a reverse proxy needed so we can access the BFF on the same site. Angular has this feature built‑in. It was originally designed to cope with course problems during development, which is, of course, also an additional benefit of using this pattern. The proxy can be configured by editing proxy.conf.js. Here a target URL can be defined, which is the URL of the BFF in our case, and then URL templates can be created that will now be routed to the target. So here all requests with URLs that start with /bff will be routed to the BFF. That will cover the login, logout, and user endpoints. Also, /account and Bootstrap are needed to show the BFF login page, and these endpoints are added so that callbacks work from the identity provider. We will need them when we add OpenID Connect in a minute. And /api covers all API endpoints on the BFF. This works great while developing the application. In production, separate builds should be made and deployed, and an actual web server like NGINX should be used to set up the reverse proxy. There is another thing I want to show you. In the Angular application, there is a registered HTTP interceptor. It does two things. It sets the withCredentials flagged to true for each request. This will ensure the cookies will be sent along with requests sent by the Angular application. And it sets an HTTP header called X‑CSRF with the value 1 for each request. The BFF library we're using requires this header to be present when the session management endpoints, as well as the API endpoints are called. The BFF middleware and the marked BFF endpoints enforce this. It is a simple method on top of SameSite cookies to prevent cross‑site requests forgery attacks. When a custom HTTP header, any header, in fact, is present on any request done from JavaScript, a CORS preflight check is always done by the browser that checks the course policy before actually sending the request. Because the BFF requires this, attackers on a cross‑origin domain will be forced to send this header along, which will trigger the check with the request being rejected. When both applications run on the SameSite, course isn't really an issue. But the BFF doesn't know about that. It should be viewed as an extra security layer on top of Sae side cookies.

Adding OpenID Connect
The BFF now authenticates users itself, and it offers API endpoints that can only be accessed by the SPA because they require the SameSite cookie. Although there's nothing wrong with that from a security perspective, probably centralized authentication using an identity provider is preferable, and besides, it's likely that there is a need to access APIs outside of the BFF that can be protected with an access token. To add OAuth or OpenID Connect, there is no need to change anything in the Angular application, since it isn't aware of the complexities around authentication at all. It just calls endpoints on the BFF when it wants to do something. To switch to the OpenID Connect configuration we already have in the BFF, we can set the scheme that is used for the challenge and sign‑out actions to OpenID Connect. The DefaultChallengeScheme configures which scheme should be used when users try to access resources for which authentication is required and they are not authenticated yet. Since that is now set to the OpenID Connect scheme, we should get a redirect to the configured identity provider just like when the sign‑out action is triggered. For all other scheme actions, such as authenticate, which queries the claims of the user, we still default to the cookie scheme. We are still setting a session cookie in the browser as before. The only thing that changes is how the user's identity is obtained, since it is now coming from the OpenID Connect identity provider. When I now run the BFF project and log in, a login page shows, but this time it isn't the login page on the BFF. That isn't used anymore. Instead, the login page on the identity provider shows Bob with password Bob or Alice with password Alice works on this demo instance. Also, notice that I can now also login with Google, an external authentication provider. Again, the Angular application has no knowledge about these. All I have to do is to enable them on the identity provider to add this functionality. That also goes for things like 2FA and passkeys. The claims now reflect the identity of the user as it exists on the identity provider. The claims that start with bff: are claims set by the BFF library used. There is a logout_url, which now contains a required session ID. To log out, the session ID has to be provided, again, to protect against CSRF. Attackers could attempt to log out the user by simply doing a GET request to this endpoint without requiring a parameter. As you might recall, the demo application uses this claim to get the logoutUrl, and session_expires_in contains the number of seconds the current session will be valid for, while session_state contains the session_state value returned by the identity provider. Taking a look at the most important parts of the OpenID Connect configuration, the location of the identity provider is configured here. We're using a hosted demo version of the Duende identity server here, but it could be any identity provider vendor, such as Auth0 or Microsoft Entra ID, for example. On the next lines, the ClientID and secret are set. A secret is used to exchange the code for the tokens during the backchannel request. With ResponseType we're indicating that we want authorization code flow, so we're getting back a code as the response to the authentication request. Next are the scopes that we're requesting. OpenID will result in an identity token with the subject ID, the unique ID of the user. And profile is a scope defined in the OpenID Connect standard that will add other claims like name and address information if present. API is an API scope that will get an access token for an external API, in this case, simply named API. And offline_access will request a refresh token, along with the access token. Note that all this also has to be known on the identity provider for this client, along with the return URL that is used when the identity provider calls back to the client with, in this case, the code. How to do this depends on which identity provider is used. On the landing page of the identity server demo, we can see how the client is configured there and that these match with the BFF configuration. Now I realize that this clip in particular assumes a lot of knowledge about OpenID Connect. If you found it challenging, I would like to remind you that there is a more detailed course on Angular authentication available.

Calling External APIs
The Angular application so far uses API endpoints present on the BFF, but we now have an access token for an external API to our disposal, since the API scope is requested. The API the access token is for is included in the demo code, and it has the exact same endpoints as the internal API. It, too, is an ASP.NET application, and this time authentication is configured with a scheme called token that uses your bearer authentication, which means authentication with an access token. We're telling it to trust access tokens from the demo identity provider, and instead of using the built‑in check for an audience claim, two authorization policies are defined. One makes sure the claim scope with the value of API is present in the access token. That way it is certain the access token is meant for this API. And secondly, that access token should contain a sub, subject ID claim, making sure this token is from a user and not one acquired using client credentials flow. These policies are applied to a house group that contains all the end points we need for the application. Remember that we need another reverse proxy built into the BFF in this case to forward requests to the external API because the Angular application doesn't have the access token. To switch from internal API to external API, again, there's no change necessary in the Angular application because the endpoints have the same relative path. So all that is needed is to change the behavior in the BFF when the API endpoints are called by it. To do that, I comment out the internal API endpoint configuration and comment in this code, which calls the extension method MapRemoteBffApiEndpoint provided by the BFF library. This will forward incoming requests that's start with /api to our external API while taking care of attaching the access token. Should you try to run this configuration, remember that now two projects have to be started. First, the API and then the BFF. After logging in, you can see the functionality and data in the app is exactly the same, but now the external API is used. The access token has a limited lifetime after it needs to be refreshed, but luckily, we also requested a refresh token. There's nothing to be done, though, when using this BFF library. Before attaching the access token, it will check if it is still valid, and if not, refresh it automatically. Alternatively, the refresh token can manually be sent over to the token endpoint to get a new access token. That's a wrap for this module. We're looking at ways to do authorization in Angular next.

Authorization with Route Guards and Conditional Rendering
Authorization Rules
Our focus has been on authentication so far, which is about verifying the identity of a user. However, it is equally important to restrict what actions the user is permitted to perform. This process is known as authorization. So where should authorization be implemented? It is crucial to clarify that if an identity provider is used, it is responsible for authentication. It supplies claims that can be used for authorization. It does not enforce these claims. The actual implementation of authorization must occur within all applications that receive the claims. This includes the frontend, BFF, and any external APIs in use. In fact, we have already implemented a basic form of authorization in the Angular application. We verified if a user was authenticated and adjusted the user interface accordingly. On the back end and the external API, access to endpoints was also restricted to authenticated users. You might think, why should the same authorization rule be implemented at multiple levels? Would it not just be enough to perform this check just on the front end and hide UI elements when a user lacks the permission? The answer is no. This is a critical point. All browser content can be altered by the user, and hidden UI elements can easily be revealed. Therefore, authorization rules must be implemented both on the front and the backend. Given the inherently untrustworthy nature of the browser environment, frontend checks should be regarded primarily as enhancements to user experience rather than as security measures. The backend or API must enforce the definitive security controls. Please note that while more complex authorization rules will be introduced within the Angular application in this module, these rules will not be applied to the backend.net applications. You already saw an example on how to use authorization policies in ASP.NET when I talked about the external API. And if you want a full story, you should refer to the dedicated course on ASP.NET Core authentication and authorization.

Conditional Rendering with Authorization Data
To begin applying authorization, let's take a look at the Add button because a new requirement came in. It should only be displayed if the user's role is admin. I've reverted the BFF back to just cookie authentication without OpenID Connect simply because we have easier control around the user's claims in that way. In the login page of the BFF, I'm adding a claim role with value admin for Bob. In a scenario where OpenID Connect is used when adding claims to a user on the identity provider, you should make sure that the claim is covered by a requested scope. To facilitate the authorization around the Add button, in the AuthService, an extra computed signal can be added that gets the value of the role claim. Note that claim type role can occur multiple times. If that's the case, you might have to adjust the code here. The button is rendered in the house‑list.component. The Signal reference can now be copied in its code, and in the HTML of the component, the extra check can be added. While this approach works, it is not recommended. The actual authorization rule is now present in the HTML of the component, which, if replicated across many components, would scatter authorization logic throughout the application. A better practice is to centralize all authorization rules. One way to approach this is to make the current computed signal private and create another computed that contains the rule and has a name that semantically covers it. The rule itself is now in the AuthService instead of the UI, and if other rules are added, they will be in this central location. Let's adjust the authorization around the Add button in house‑list.component. Here's a little sidebar. Right now the authorization rule we created is just relying on a claim that is in the session. When using OpenID Connect, these types of claims should only apply to the complete application landscape of an organization. If application‑specific authorization data is needed, a common pattern is to create a separate authorization API protected by an access token that is called with some kind of application ID. Now, when the Angular application calls the endpoint, it could use caching logic similar to what we have around calling the user endpoint. Using that method, the global claims can come from the identity provider and authorization data that is more specific to the application from the authorization API.

Securing Application Routes with Route Guards
Angular provides a mechanism to protect routes from unauthorized access known as route guards. They protect access to Angular routes by calling functions. We're first adding another authorization signal to the AuthService called canSeeHouseDetails that too checks the role claim for the value admin. In the app.routes.ts file where routes are configured, there's a route for house/id that renders the HouseDetailComponent. By adding a canActivate property to the route configuration, an array of functions can be specified, all of which must return a truthy value for the route to activate. In this example, only one function is called, the authorization method on AuthService. Angular's inject function is used to obtain an instance of AuthService on which the method is called. When clicking a house in the list, the route activates and the canActivate functions execute. Since Bob is an admin, the function we added returns true, allowing access. However, if the required role is changed to one Bob does not possess, clicking a house results in no action, as the route refuses to activate. In the demo application, the routing table is simple. For more complex routing, such as a product route with child routes, the canActivate guard can be used to check if the user is authenticated. Only authenticated users can activate the product route and its child routes. Route guards can be nested. For example, the product route and all child routes require authentication, but access to a particular child node may require an additional check via a hasProductAccess method on all servers. In cases where multiple child routes share the same guard logic, like in the previous example, Angulars can activate child guard is appropriate. The product route users canActivate to check authentication, while canActivateChild applies the hasProductAccess check to all child nodes. Another useful route guard is canMatch, which allows different components to be rendered for the same route based on authorization rules. For example, three routes with identical paths are evaluated in order. If canShowAdminList returns true, the ProductListAdminComponent is rendered. If not, the authenticated property is checked to render ProductLisComponent. Otherwise, the ProductListAnonymousComponent is rendered. So, this is quite a powerful feature. Also, route guard functions can accept two parameters to gain additional context. The first provides information about the route being activated, and the second allows inspection of the current state of the router. And this is useful for scenarios such as examining query strings with guard logic. And that was it for this course. Thank you for watching, and see you next ti