What Angular Does by Default
What Is Change Detection?
Have you ever wondered how Angular knows when to update what you see on the screen? Why does your app magically refresh when you type, click a button, or load new data? In modern web apps, things are always in motion. You might add a new item to your to‑do list, get a notification, or update your profile. As a user, you expect the UI to respond instantly, no matter how often your data changes. But how does Angular keep your app in sync with your data? Let's say you have a simple counter app. You click a button and the number goes up. Or you receive some new data, maybe a message or an updated chart. Angular's job is to detect these changes in your data and make sure your UI always reflects the latest state. This is what change detection is all about. Angular has a built‑in system that's constantly watching for changes in your app's data and then updating the UI so everything stays in sync. This is what makes Angular apps feel so responsive. You don't have to manually update the screen every time something happens. Angular's change detection does the heavy lifting for you. But how does Angular actually know when to run change detection? And what's really going on behind the scenes? Well, that's exactly what we'll uncover next.

What Is Zone.js and How Does It Work?
So, we know Angular has this change detection system that keeps your app in sync. But how does it know when anything in your app changes? The answer is Zone.js. Zone.js is a tiny, but powerful library. Think of it as Angular's old magic trick. It's not part of the browser and it was not written by the Angular team, but Angular has relied on it to watch everything happening in your app. Zone.js does something called monkey‑patching. That just means it sneaks in and wraps itself around browser events, timers, and asynchronous actions. Whenever you click a button, set a timer, or make an HTTP request, Zone.js is right there quietly watching. No matter what kind of event happens, a button click, a set timeout, or a response from your API, Zone.js intercepts them all. Imagine an Angular app with a tree of components, a sidebar, main content, notifications, and more. When any event occurs, Zone.js immediately tells Angular, hey, something happened, and Angular responds by running change detection across every component in the tree, from the root component all the way down to the smallest grandchild. This is what we call the cascade. No matter where an event starts, every single component in your app gets checked for changes, even if they weren't affected at all. This is usually fine in small apps, Angular is fast and your UI always stays up‑to‑date. But as your app grows, this checking every time approach can become a real performance bottleneck. Even if only one component actually changed, Angular will still check all the others again and again. And that's why it's so important to understand how Zone.js triggers change detection. In small projects, you might never notice. But as your application gets bigger, you could start to see slowdowns or mysterious bugs caused by all this extra unnecessary work. Okay, up next, we'll get hands‑on with a demo, and you'll see exactly how this cascade works in real life.

What Types of Events Trigger Change Detection?
So far we've learned what change detection is and how Zone.js acts as the event watcher for Angular. But what does this actually look like in a real app? Well, let's take a look. But before we do, if you want to code along, I've provided the demo code for this course in a GitHub repository that can be found here. All you'll need to do is clone down the repository, run npm install to install dependencies, then run npm start to build and run the app locally. Okay, here we're using a demo app with a sidebar, main content, and a footer, each made up of nested components. Each component logs to the browser console whenever Angular checks it. So, if we reload the app, we can see that every component logs out actually twice. That may seem strange, right? I mean, if it logged out once, that would make sense, but twice is odd, right? Well, we're using the ngDoCheck lifecycle hook to log these messages out, and that runs on every change detection cycle. What's actually happening here is that the first check is part of the standard rendering process, while the second is a development mode specific stability check driven by Zone.js to prevent data inconsistencies. So we see two logs up front. Now look what happens in the console when I click Mark All Red button in this notification panel. You'll see logs for every component, not just the notification panel. This actually illustrates one of the main issues with default change detection. Every event, no matter where it starts, triggers a check of the entire component tree. This tells the entire application to update its view. Yikes! Now what about timers, like setInterval or setTimeout? Well, here in the ActivityFeed component, we have a set interval timer that increments the last activity. Let's uncomment it to see what happens. Okay, let's save and look in the browser again. Notice how the console logs keep appearing. Every second, every component is checked, not just the activity feed. A single timer can keep your whole app busy. Now, observables can also trigger change detection cycles. Here in our notification panel, we have an observable subscription from a notification service. We could imagine that this data might come from a web socket or an HTTP request. Let's uncomment it and see how it affects change detection. Okay, let's save and check the console now. Once again, even though only the notification panel really cares about this event, every component is checked. So just like with timers and clicks, async streams from observables also trigger Angular's full change detection cycle. Now, what if we switch this to use the observable directly in the template with the async pipe? Let's try it out. Now, let's save again and check the console. Okay, same thing. The async pipe will cause a change detection cycle, too. So to recap, all of these trigger a cascade, causing Angular to check every component, even if nothing in those components changed. As your app grows, this default behavior can mean wasted CPU and slower performance, especially if you have heavy taxing components. So, what can we do to avoid this? Well, that's what we'll talk about next.

OnPush Change Detection (With Zones)
Now that you've seen how Angular's default change detection works, you can see that it's basically a machine gun style approach out of the box. But luckily, we're not stuck with this concept for change detection overall. We do actually have some control, we can and really should use the OnPush change detection strategy to better optimize performance. So we now know that by default, Angular uses Zone.js to patch browser events. That means every browser event, clicks, HTTP calls, even timeouts are intercepted. And Angular automatically checks your whole component tree for changes. It's great for developer convenience, but sometimes it makes the browser work harder than it should, especially in large apps. The OnPush strategy is Angular's way of giving you more control over change detection. With OnPush, Angular only updates the component when an input changes, you trigger detection manually, or a handful of special events occur. It's a bit like telling Angular, only check this component when something important happens. So how exactly do we do this? Well, first, let's open the code for our demo app again. In order to switch to OnPush, we need to add the changeDetection metadata property to our component. Now we'll use the changeDetection strategy enum from Angular Core. Then we'll use OnPush. And that's it. This component is now set up to use OnPush. The kicker here is that we need to update all of our components with this change for OnPush to function correctly. So rather than bore you by modifying the code for every component in this app, we'll just fast‑forward instead. Now every component is configured to run OnPush. Okay, now let's save and try this out. Now, when the app reloads, we only see one set of component changes for each component as opposed to the two that we saw before. Now, let's click the Mark All Red button and see what happens. Nice! This event no longer triggers changes for all components. It's only triggering changes for this components tree and its siblings. The Sidebar and Footer components fired changes because they're siblings of the main content component. The MainContent component fired a change because its child caused the change. The notification component fired because it's the component that caused the change with the click. And finally, the NotificationItems fired because their input values changed, but neither the user profile or the activity feed components triggered a change because they are part of a different tree structure. You can probably start to imagine the impact this would have in larger Angular apps. So, OnPush tells Angular to skip components unless they themselves, their siblings, or their children change. That's definitely an improvement overall, right? That's the magic of OnPush. Angular only checks and re‑renders components when needed. This means that it often avoids unnecessary expensive calculations. And this makes your app faster, especially as it grows in size and complexity.

The Case for More Control
So, you've seen how Angular's default change detection makes sure the UI always stays in sync. But here's the real challenge. Convenience can come at a cost. OnPush helps, but it's certainly not perfect. There are often still many unchanged components involved. As your app grows, some components get more complex and more expensive to update. Maybe your dashboard now includes a chart that visualizes lots of data, a list with hundreds of posts or notifications, or widgets that recalculate stats. These parts of your app do real work every time change detection runs, not just when their own data changes. If an activity feed timer ticks or a background observable fires, even if the only thing that actually changed was the activity feed, Angular's default change detection will still check the chart, the post list, the notifications, the sidebar, the footer, every single component. And if that chart component is heavy, your whole app can feel slower, even though nothing new is being displayed. This can make the UI feel sluggish. Your CPU usage may spike. Your battery will drain faster on mobile devices. And debugging can be trickier because things are running more frequently than they should. Wouldn't it be better if we only check components when they themselves changed? If we could prevent expensive updates unless absolutely needed? If we had more precise control, especially in the biggest, most critical parts of our app? That's where zoneless Angular comes in. With it, we can cut down on wasted work, make even the most complex dashboards feel lightning fast, and predict exactly when and where the UI will update. In the next module, we'll see how to put these advanced techniques into action and finally take control of change detection in Angular.

Going Zoneless
Why Go Zoneless?
Up to now, we've seen how Angular uses Zone.js to automatically detect when your app needs to update. But what if you want more control and less hidden magic? That's where zoneless Angular comes in. Zoneless means no more Zone.js. No more monkey‑patching browser APIs. You tell Angular exactly when to update the UI. This gives you fine‑grained control and can unlock better performance, especially for big, complex apps. So why would we want to go zoneless? Well, it helps us avoid hidden performance costs of checking the whole component tree. Since we no longer include Zone.js, we'll end up with a smaller bundle size. Also, since Zone.js is no longer loaded, the result should be a faster start‑up time. It reduces surprises. Nothing updates unless you ask for it. And it'll help us get ready for the next generation of Angular change detection. Okay, now that we have an idea of what zoneless is in Angular and why we'd want to use it, let's look at exactly how we can make the switch.

Making Your App Zoneless (Step by Step)
Now that you know what zoneless Angular is and why it matters, let's actually make the switch in our existing demo app. But first, it's important to note that currently the API for enabling zoneless is in developer preview. This means that some or all of what we'll see here may change. Okay, to go zoneless, first we need to open the file where we Bootstrap our Angular application. For us, this is in the main.ts file. Here in the provider's array, you may have guessed it, we want to remove the old provideZoneChangeDetection function and its import. We don't need this anymore. Instead, we'll replace it with the new provideZonelessChangeDetection function instead. And we need to be sure that it gets imported from Angular Core. Okay, now we need to open up our angular.json config. Here, we want to search for Zone.js and remove all of these includes. Even this testing include. None of these are needed any more. One important note, if your app has an explicit polyfills file, ours does not, you'd need to remove these same imports from it as well. Okay, at this point, we've removed Zone.js and are now running zoneless. Let's look at the app and see if it still works. Well, it looks like it, right? But look here at this warning message we're getting in our console. It's letting us know that we're now running in zoneless mode, but we're still loading Zone.js. Well, this is because we still need to do a couple more things. For one, we modified our Angular config, but never restarted our app, so it's still running based on the old configuration. So let's switch to our terminal and stop our application. Now, we can uninstall Zone.js since we're not using it anymore. Okay, that's it. Now we should be able to restart the application. Okay, looks good now, right? And we no longer get the warning in the console, either. We are officially zoneless. So this is how you switch an existing stand‑alone application over to zoneless. One important note here, in this app we are using standalone components, but if your application is still using modules, you'll need to be sure to provide it in the root module for your app instead. Also, if you're generating a new application using the Angular CLI, you'll have an option when setting up the new project to go zoneless right out of the gate. Okay, now that we know how to go zoneless, let's see what works and what breaks now that we've made this switch.

What Breaks in Zoneless Angular
Okay, now that our app is running without Zone.js, things will work differently. With Zone.js, Angular automatically tracks every user event, timer, and async operation, then runs change detection everywhere. Without Zone.js, Angular only updates when you tell it to, for the most part, but there are some exceptions. Let's see what's changed. First, let's try clicking a button in the app. For example, the Mark All Red button in the notifications panel. You might be surprised; button clicks still update the UI. Why is that? Well, Angular's default event bindings, click, focus, blur, etc. still trigger change detection even in zoneless mode. This is a built‑in behavior to keep template‑driven interactions working. But other triggers won't work unless you wire them up manually. To better understand this concept, let's look at the activity feed timer. Let's uncomment this setInterval again and see what happens. Well, it looks like this no longer works like it used to. Without Zone.js, the timer's callback runs, but Angular doesn't know anything changed, so the UI never refreshes. Now, let's try triggering a background observable, like our simulated notification stream. Let's uncomment the observable subscription so that it will run properly again. Nope, that doesn't work, either. Again, without Zone.js, async events do not cause Angular to update the UI unless you tell it to. But there is something interesting here. This observable is actually set up so that we can switch and use the async pipe in the template. So, let's try this out. Okay, now let's save and see what happens. Well, when the observable emits, the async pipe takes care of triggering change detection automatically, even in zoneless mode. This is because the async pipe actually uses the change detector ref behind the scenes and uses mark for check to let Angular know to run change detection. Using observables with the async pipe will continue to function properly just like event bindings. So, what exactly is happening here? Zone.js used to monkey‑patch everything, so Angular always knew when something changed. But Zoneless Angular isn't watching timers, observables, or promises anymore. For async changes, if you want the UI to update, you must tell Angular. Up next, we'll deep dive into the various methods to bring back reactivity for the things that break after switching to zoneless.

Smarter Change Detection Techniques
OnPush in Zoneless Angular: Does It Still Matter?
So, we've gone zoneless. We no longer have Zone.js patching every browser event, and we're no longer getting automatic change detection for free. Which raises the question, does OnPush still matter in a zoneless Angular app? Short answer, yes. But how and why it matters is slightly different now. Let's walk through it. In a zone‑enabled app, OnPush tells Angular, don't run change detection on this component unless something important happens. And important means an input changes, a manual trigger is called, or a handful of special events fire, like user input. This gives you smarter change detection, even with Zone.js trying to run the show. But now that we've disabled zones, let's see what happens. Okay, we're looking at our demo application that we just converted to zoneless, but I've rolled back all of the components so that they no longer use OnPush. And now the logs are similar, but a little different. The entire tree is still being checked, so each component still logs out when initialized, but only once this time. So that's a change, but other than that, it's basically the same. Now let's click the button to trigger change detection. Okay, the entire tree gets checked again. This could mean that we're doing too much, right? We could be causing components to be checked, even though they haven't changed, just like we saw in the default app with zones. Let's try switching to OnPush now. You've seen this before, so I'll fast‑forward through the changes. Now every component in this app is running with OnPush again. And we still see each component logs out on initialization, like before. Now let's click the button. Nice, just like in zone‑enabled applications, when we trigger a change detection event, only the components that actually need updating are checked. It only triggers changes for this component's tree, its siblings, or components where an input has changed. Everything else skipped. So, here's the key idea. Without Zone.js, you decide when Angular runs change detection. With OnPush, you decide how far it spreads. If you skip OnPush, every manual trigger will walk your entire component tree. But with OnPush, Angular can skip massive parts of the UI that didn't change. And that means less work, less CPU usage, and a faster app. Even zoneless apps need boundaries, and that's why OnPush is just as important, maybe even more important, in a zoneless Angular app. So now we know that OnPush still matters in a zoneless app, but what do we do when components stop updating after going zoneless? Don't panic. Up next, I'll show you how to bring them back with fine‑tuned manual change detection.

Manual Change Detection: Fine-tuned Control
If you're coming from a Zone.js‑based Angular app, switching to zoneless will break some of the change detection behavior you're used to. One of the simplest ways to restore that behavior is to manually tell Angular when to update the UI. In a new zoneless app, you'll likely rely more on signals and other reactive patterns. But manual change detection is still essential when working with third‑party libraries or untracked observables. Before we get into it, it's important to understand that in zoneless Angular, there are now four scenarios where change detection will run. First, there are event bindings, like click, for example. Then we have manual change detection. This is when we notify Angular ourselves of a change. After this, change detection will also run when signal values change. And finally, change detection will run when we use setInput on dynamically created components. We will see all of these and more in action, but here we're focused on manual change detection. So, let's look at the tools Angular gives us for this manual control. For manual change detection in Angular, we have the ChangeDetectorRef class. It gives us two separate methods to manually update change detection, markForCheck, and detectChanges. MarkForCheck just tells Angular, remember me? I'll need an update. It marks your component and all its parents as dirty. But it doesn't do anything right now. The next time change detection runs, say, when a parent triggers it, the component will update. DetectChanges, on the other hand, is immediate. It says update this component and everything under it right now. But it doesn't look up the tree, only down. Okay, let's see this in action. Here, we are subscribing to a notifications observable from our notification service. Let's imagine that this is some sort of third‑party service that we can't modify. And what it does is emit when it has new values. When that happens, our list of notifications is updated. Now, right now, since we are in a zoneless application, this will not update the template as is. Let's add a console.log here to better illustrate what's happening. Okay, let's save and check this out now. Here we can see that the notifications observable is properly firing, but these changes are not properly being reflected in the UI. This is because Angular no longer knows these changes are occurring. We need to let it know that this component needs to update. So let's switch back to the code to see how to do this. First, we need to inject the ChangeDetectorRef so that we can use it. Now, we can manually trigger change detection. Let's use markForCheck first. Okay, now let's save and see how this works. Okay, now, after the timer fires, Angular schedules an update for this component and its parents. So, we've now restored the UI. Angular is now being properly notified that this component tree needs an update. This looks a lot like what we've already seen. This component, its parents, and its children are marked dirty, so that Angular knows to check them. So, that's markForCheck. Now let's try detectChanges. Let's switch back to the code. Then we simply change this to detect changes instead. Okay, now let's save and try this again. Now, when the timer fires, the UI still properly updates, so Angular is aware of the fact that it needs to update the UI. But this time only this component and its children are checked. The parent and siblings are not. So we can see how they work differently here, but what we're not seeing is that detectChanges immediately triggers a change detection cycle. It forces a synchronous update of the view. So, while it will update the view, it's a more aggressive approach than markForCheck. So, to sum up, use markForCheck in most cases if you want Angular to update this component and parents at the next opportunity. Use detectChanges for an instant, more forceful update of a specific component and its children. But manual change detection is just one way to notify zoneless Angular changes. Often, there are better methods available. Up next, we'll look at how using the async pipe with observables will automatically trigger updates even in a zoneless app.

Async Pipe with Observables: Still a Smart Move?
In traditional Angular apps that use Zone.js, the async pipe has long been considered a best practice when working with observables. Why? Because it eliminates the need to manually unsubscribe, and it plays nicely with Angular's built‑in change detection. Well, in zoneless Angular, that advice still holds up, but not exactly like it used to. If you remember from earlier in this module, there are four scenarios that can trigger change detection in a zoneless app, event bindings, manual change detection, signal writes, and setting inputs on dynamically created components. We just saw how markForCheck can manually trigger a change detection cycle, but here's the interesting part. The async pipe calls markForCheck under the hood. So, yes, even in zoneless Angular, the async pipe still works without any extra code from you. Let's go back to the code for our notifications component example. Previously, we injected the ChangeDetectorRef and manually triggered change detection when the observable emitted new values. So let's clean that up. First, we can remove the ChangeDetectorRef dependency from our component entirely. Now, I need to make sure that we're updating our notifications behavior subject when the service fires because this is the observable we're using for the for loop in the template. A little disclaimer here, you would not want to set an observable within an observable subscription like this in the real world. There are much more elegant ways to do this type of thing. But for this demo, this will be enough to illustrate the role of the async pipe. Then we just need to import the pipe in our imports array to make it available in the template. Now let's switch over to the HTML and bind directly to the observable using the async pipe. Okay, now let's save and take a look. Perfect. Same behavior as before. When a new notification is emitted, the component and its tree update, just like they did with markForCheck, because under the hood, that's exactly what's happening. Angular knows this component should be checked, and the update happens as expected. Now, the way that I have this particular demo observable set up, I can't easily remove the notificationService observable subscription. But most of the time in the real world, you'd be able to eliminate the subscription and takeUntilDestroyed when using the async pipe, which makes it a much more elegant solution than what I'm showing here. So, is the async pipe still relevant with zoneless change detection? Yes, it's still a valid tool, especially if you're still working with observables. But there's often better methods to use in modern Angular. The big one is signals. They offer an even simpler, more native way to build reactive UIs without needing pipes or subscriptions at all. Coming up next, we'll take a closer look at signals and how they give us a completely different way to react to state changes in Angular.

Signals: Angular’s New Reactive Power Tool
So, we know that the async pipe still works in zoneless Angular, thanks to the fact that it calls markForCheck behind the scenes. But what if we could skip the pipe or the need for manual change detection entirely? This is where signals come into play. Signals are a new reactive state primitive in Angular. They automatically track dependencies and update the UI when their values change. No Zone.js, no async pipe, and no manual triggering. And remember, they are one of the four scenarios that trigger change detection in zoneless Angular applications. They are really the primary mechanism for reactivity because they directly inform the framework when data changes. Okay, let's walk through an example. Right now, this component is using a behavior subject with an initial list of two notifications. Let's clean it up. Let's replace the notifications property with a signal using the signal function. We'll type it as an array of notification objects and give it the same initial value as before. That's it. We've got the same data, but now it's fully reactive. Next, let's handle incoming notifications from the service. Previously, we subscribed to the observable and pushed the new value to the behavior subject. Now, we'll use the update method on the signal instead. This gives us access to the current signal value. Where we can return a new array with the incoming notification added. Okay, now that we are no longer using the behavior subject, we can remove it. Since we've removed the behavior subject, we also need to update the markAllRed method to work with our signal. We'll use the update method again to update the signal. Then we'll just map the values in the array again to make them all red. Now that we're not using behavior subject or the async pipe anymore, we can clean up the imports. I'll go ahead and remove both from the top of the file. Now let's switch over to the template. Let's simplify the for loop to use the signal instead. Since notifications is now a signal, we just call it like a function. Also, we can now remove the async pipe since we don't need it anymore. Okay, that should be everything. Let's save and see it in the browser. Perfect. It works exactly as expected. The initial notifications render, new ones are added in real time, and the UI updates automatically. And if we click the Mark All Red button, everything updates accordingly. But if you look at the console, there's something even better happening. Outside of that button click that triggered change detection for the entire tree, Angular is only updating the components that actually changed the individual items, nothing more. That's the real power of signals in zoneless Angular. You get fine‑grained updates without wiring up lifecycle hooks, zone‑patched events, or manual Change Detector Ref calls. It's reactivity that just works. So, what's the takeaway here? Well, for one, the main goal in a zoneless Angular application is to utilize signals for as much component state and data that needs to trigger UI updates as possible, since they are optimized for this environment. Updates are reactive and targeted. Only the components that are changed are updated. The result is simpler code, more predictable behavior, and improved performance across the board. And the best part, we're just getting started. Up next, we'll explore how to take this even further by converting existing observables into signals.

From Observables to Signals: The Modern Path
We've already seen that in zoneless Angular apps, signals give us the cleanest and most efficient way to handle state and UI updates. But what if you already have observables? Is there a way to use them with signals without manually subscribing or using the async pipe? Well, actually there is, and it's the toSignal function. So, what is toSignal? This is Angular's official bridge from observables to signals. In a way, it can kind of replace the async pipe. It manages subscriptions for you and integrates seamlessly with the signal reactivity model. So how do we use it? Well, let's check it out. Let's start by creating a new signal called incoming. To do this, we'll use the toSignal function from the RxJS interop module. Then all we need to do is pass it our observable plus an initial value, in our case, null. Now we have a signal that updates every time the observable emits, but here's the trick. We want to update our existing notification signal, too. If you're familiar with signals, you might think computed is the way to go here, but not this time. We still need this signal to be writeable because we modify it when the user clicks Mark All Red. So instead, we'll use linked signal, which is a writeable signal that can react to changes from another signal. The first thing we need to do is provide the signal that we want to update based on, this is considered the source, and in this case, it'll be our incoming signal from the observable. Next we have the computation function that will run when the source signal updates. This function has two parameters available. The first is the current value of the source, we'll call this incoming, and it'll be typed as a notification object or it'll be null. The second parameter is the previous value. It'll be an object with a source that will be either a notification or null, and it'll have a value, which will be an array of notifications. The first thing we want to do is handle the initial value, so let's add a condition to check when we don't have a previous value. The only time this should happen is on initialization. Within this, let's just return our initial notifications array. So when this fires for the first time, it'll just return the initial notifications. Now we need to handle all other cases. If we have an incoming value, we need to add the incoming notification to the list. If not, we'll just return the previous value. And that's it. We've fully switched from observable base state to signal‑based reactivity. Now, let's remove the original signal. And this also means that we can now remove the whole observable subscription and even the constructor, since we're not using it. Let's also remove any unused imports. Okay, that's it. We don't need to change anything in the template because it was already configured to use the notification signal from the previous example. So, let's save and check it out. Look at that. Everything is working just fine, right? The initial items load out of the gate, new items enter in real time, and then when we click the Mark All Red button, everything is updated correctly. And just like the previous signal example, the notification items are the only components being updated because they are the only components who are changing. So by converting the observable to a signal with the toSignal function, we've simplified things even further. That's the power of signals. They're lean, efficient, and play perfectly with Angular's zoneless rendering model. So we can use toSignal to convert observables into reactive signals without manual subscriptions. It can replace the async pipe in many cases. And it affords us a path forward with signals, even when we are unable to completely move from observables to signals. And it can even further improve performance. Okay, up next, let's explore how dynamically created components set their inputs and exactly how this plays out in a fully zoneless Angular app.

Fixing Change Detection for Dynamic Components
Dynamic components in zoneless Angular may work a little differently, and the old tricks may no longer cut it. We've seen how events like button clicks just work in zoneless Angular without any extra effort on our part. We've seen how signals give us clean, reactive state management in zoneless Angular. We've learned how the async pipe still works by calling markForCheck under the hood. But there's one more scenario we need to address, dynamic components. When you're creating components dynamically at runtime, you need to know how to properly update their state without breaking change detection. The old patterns of using injection tokens and direct property assignment simply don't work reliably in a zoneless OnPush world. So here I'll show you how to modernize your dynamic component approach using patterns that work beautifully with zoneless Angular's change detection system. If we refer to our list of scenarios that trigger change detection in zoneless apps, that last one, setInput, is exactly what we'll focus on here. Okay, I've temporarily switched the app back to run with Zone.js. Now, you may be noticing the app has changed a little bit. We have this message above the notifications list. Now, let me refresh so that you can see this. When the page loads, you can see we get a "Welcome to the app!" message, and then after a couple of seconds it updates to, "We're glad to have you back!" So, this works as expected in an app with zones, but this implementation has some issues that we need to address when moving to zoneless Angular with OnPush change detection. Let's look at some code to better understand what's happening here. First, let's look at the welcome component. This component dynamically creates a message component and inserts it in its own template. The first thing to notice is that we're not using OnPush change detection strategy. This component is using the default change detection. If it were using OnPush, it actually wouldn't work properly. Then we have an effect that watches for the container view child, and once we have that container, we call the createWelcomeMessage function. This function is where we create our dynamic component. In this function, the first thing we're doing is creating a custom injector in order to provide the initial value 'Welcome to the app!' to the dynamically added component. Then we create the component within the container, providing it the custom injector. After that, we have the set timeout that waits 2 seconds and then directly assigns a new value to the welcomeMessage property on the component instance. Now let's look at the message component to understand how it receives this data. Here we inject the custom welcomeMessage injection token to access the data that's injected. Then we set the internal welcomeMessage property using that injected value. So this approach worked fine in our Zone.js application, but not so much when we moved back to zoneless with OnPush change detection. Here we are back in our zoneless application, and you can see I've already added OnPush change detection strategy to this component. All of our components are now using OnPush. But now if we look at the application, you'll notice something's wrong. We get the initial message, but after the timeout, it doesn't update like it used to. After refreshing, you can see the dynamic update is no longer working. This is because we're directly assigning to a property which doesn't trigger change detection in OnPush components in a zoneless environment. So let's fix this, and when we do so, we're going to simplify the entire approach. First, let's clean up the createWelcomeMessage method. We're going to remove this entire customInjector setup, since we won't need it anymore. This means that we can also remove the injector property. And the associated imports, and we can also remove the custom injection token, too. Now let's simplify the component creation. I'm just going to call the createComponent method and pass it the MessageComponent by itself, no more injector. Instead of using dependency injection to pass the initial message, I'm going to use the setInput method. Now, for the setTimeout, instead of directly assigning to the instance property, I'm going to use setInput again. This setInput method is the modern way to programmatically set inputs on dynamic components, and it will properly trigger change detection when they change in a zoneless app. Okay, that should be everything we need to do here, so now let's switch over and update the message component. All we need to do here is replace the old injection concept with a single signal‑based input using the input function. This creates a required input signal that our parent component can set using setInput. Okay, all that's left to do now is update the template real quick, since this welcome message is now a signal. Now let's save everything and see if this works now. Perfect. Now we can see it's working correctly again. We get the welcome message initially, and after the timeout, it properly updates to the glad to have you back message. So now the dynamic component is now working perfectly in our zoneless Angular application, and the setup is even more elegant, too. The key takeaway here is that when working with dynamic components in zoneless Angular, it's best to use setInput. This method properly notifies Angular's change detection system, ensuring our components update correctly. This approach is not only more compatible with zoneless Angular, but it's also cleaner and more maintainable than the old injection token approach. Now that we've covered all the fundamental techniques for change detection in zoneless Angular from OnPush to manual triggers, from signals to dynamic components, it's time to put these tools together. Up next, we'll take everything we've learned and apply it to some real‑world scenarios.

Real-world Zoneless Optimizations
Restoring Countdown Functionality
In the last module, we learned how to take fine‑grained control over when and how change detection runs in zoneless Angular. Now, it's time to apply those tools to real‑world situations. Let's start with something you've probably seen in dozens of applications, a session timeout countdown. Here, we're looking at a component from an Angular application that has just been converted over to zoneless. It should count down every second, but since we're now running zoneless, it's stuck. The seconds never change and the progress bar never moves. If we switch over and look at the component, the code looks fine at first glance. We're starting at 15 seconds, subtracting 1 every second, and pre‑computing the display string. So why doesn't the UI update? Well, in zoneless mode, setInterval doesn't trigger change detection, so Angular is never notified to refresh the view. Now, you know how to fix these types of issues in zoneless Angular. So, what should we do here? If you guessed manual change detection, well, you're right, that's one way we can do it. Let's try it. First, let's inject the ChangeDetectorRef. Then in our setInterval, let's use it to call markForCheck. That should be all we need, so let's save and see if it works now. There it is. Nice! Now the countdown updates every second. So, that's the quick fix, but now that we know more about zoneless Angular, we can do better, right? We can use signals. Let's switch back to the code and switch everything to signals. First, let's remove everything we just added. Okay, now we can switch the seconds remaining to a signal. Now, we need to convert the formatted remaining property to a signal, too. This one will be set based on the seconds remaining, so it will need to be a computed signal. This means that we can now simplify the logic in the setInterval. First, we can remove the logic to update the formatted remaining property, since this updating will now happen in the computed signal. Then we can switch to the update function for the seconds remaining. Okay, that should be everything we need here, so let's switch over and update the template now that these properties are signals. Okay, that's it. Let's save and see if everything works now. Nice. Now the countdown works without any manual change detection calls. Signals take care of telling Angular exactly when this component should update. That's a much more modern way to fix the issues here. So, what are the key concepts with this? Well, for one, in zoneless mode, setInterval won't trigger change detection automatically. Manual change detection, markForCheck, can fix the issue quickly. Signals remove the need for manual change detection and update the UI reactively. So whether you use manual change detection or signals, the important part is knowing how to connect your state updates to Angular when Zone.js isn't there to do it for you. Next, we'll look at another common scenario, reacting to external events like scrolling and see how to keep those updates efficient in a zoneless app.

When Events Don’t Trigger Change Detection
Okay, we just fixed a broken session timer in a real world zoneless Angular scenario. That happened because timers don't trigger change detection without Zone.js. And as we've seen so far, some interactions, like button clicks, still do. But many others don't. Scrolling events are one of those cases where Angular won't update the view unless we make some changes. Let's look at an example. Here's a scrollable orders list. Up top, the insights bar shows the pixels scrolled down inside the container. In this case, we're not yet scrolled, so it's 0. It also shows the range of items that are visible in the view. In this case, we're seeing the first 6 items. Now, let's see how these work when I scroll. Well, the list moves, but the numbers stay frozen. Classic zoneless symptom. This used to work before switching the app to OnPush and zoneless. This is because the code tied to the scroll handler runs, but Angular never re‑renders. Let's look at the TypeScript to better understand what should be happening. Okay, for one, several of the properties that we're using for this are plain fields, not signals. So that's part of the issue, but how are these being updated? Okay, here we're using the renderer to listen method to listen to scroll events. When an event fires, this onScroll method is called, and this is where these properties are updated. And this is the main issue. Since scroll events don't trigger change detection, the properties will get properly updated, but the view will never get notified that it needs to update. So, you know how to fix this now, right? What should we do here? Let's start with the quick fix, manual change detection. Let's inject the ChangeDetectorRef. Then let's call markForCheck. Okay, now let's save and try it out. There we go, that was easy, right? But again, this isn't really the best modern way to fix this. Now that we're comfortable in zoneless Angular, we can do even better. Let's use signals so the view updates automatically without manual change detection. Let's remove the ChangeDetectorRef. Okay, now let's change the scroll top, start index and end index properties to signals. Then we just need to update these in the onScroll function. Okay, that should be everything here. Now let's switch over and update the template. Since these are signals, we need to add parentheses to all the usages. All right, that should be it. Let's save and try this again. Nice, everything still works, and we don't have zones, and we don't need manual change detection. So, what are the key ideas here? Well, for one, imperative DOM listeners, like scroll events, don't trigger change detection in zoneless Angular. Manual change detection is a very fast and safe patch in this example. But signals really are the modern declarative fix. The updates flow straight into the template. Okay, so now we've controlled a high‑frequency UI event without zones. Next up, we'll modernize a real‑world legacy observable‑driven UI that has stopped functioning after switching over to zoneless.

Working with Third-party Library Events
Okay, so far we've fixed issues from our own code related to timers and scroll events. When using code from third‑party libraries, you probably won't have the ability to easily convert things like observables to signals. So you may find yourself needing a different approach. Let's take a look at an example. Here we have a products list. Since we have a large amount of space, there's plenty of room to display the products in a grid format with lots of data, like the rating and description, for example. But when we shrink this down, the data and layout should change to better fit the screen space. Well, before switching to zoneless, this, too, worked just fine. We are using the breakpoint observer from the Angular CDK, which is an observable. It allows us to monitor media query breakpoints and then programmatically respond when certain breakpoints are matched. It's useful when you actually need to do things like use different logic at different media queries, something that's not really possible with CSS alone. Let's look at the code to better understand what's happening here. Okay, here we can see that we have a standard layout property. Then we have the breakpointObserver class from the Angular CDK. And then down here we are subscribing to the observe method, which observes the breakpoints we give it and fires an event when they are switching from matched to unmatched or from unmatched to matched. This isn't observable, so we're subscribing to it. Then within the subscription, we update the layout property accordingly. And since this observable is provided by a third‑party library, we can't directly change it to anything else. Remember, in a zoneless OnPush app, setting a class property in a subscription does not trigger change detection. The data updates in‑memory, but the template doesn't hear about it. That's why the UI looks stuck. So we have a few ways to fix this, right? We could use manual change detection, and we know that would work, but that's not the best tool for this. Sure, it's a quick fix, but we can do better. How about an async pipe? Well, let's try it. To do this, we need to first expose the observable as a property so that we can access it in the template. Let's just repurpose the layout property for this. Let's copy our observable subscription here. Now we can't use subscribe for this anymore, so instead I'll use a map operator. Then I'll copy the logic into the map and just replace the layout property with returns instead. Now we can remove the subscribe and the constructor, too. Okay, now we have an observable that we can access. Next, we need to import the async pipe so that we can use it in the template. Okay, now we can switch over to the template and update this to use the async pipe now. All right, that should be everything we need. Let's save and see how this works. Looks good to start, right? Let's shrink it down now. Nice. Now, the UI is properly updating for smaller views. This happens because, as we saw earlier in this course, the async pipe is one of the four events that triggers change detection. So, that's cool, but realistically, we can still do better. We can and probably should use signals here. Let's switch back over to the TypeScript and update this concept. So we can leave this property with the observable as is, except we're going to change the name. This way we can create a new layout property for our signal. And how do we create a signal from an observable? We use toSignal. Then we pass it the observable and give it an initial value. That's it. Now let's switch over and update to the new signal in the template. Okay, now let's save and check it out. Again, it looks good to start in the wide view, so let's resize and see how it works. Nice. Now we're successfully using signals with a third‑party observable. So, when converting over to zoneless, if you're doing things like setting properties in third‑party observable subscriptions, it won't work without some changes. Manual change detection is a quick fix, but there are usually better options. The async pipe is a good one if you're not easily able to move all the way to signals. But the best option is to use toSignal and update everything else over to signals as needed so that you're in line with modern reactive best practices. Okay, up next, we'll take some broken runtime created components and make them play nicely with our newly converted zoneless OnPush app.

Reliably Updating Components Created at Runtime
Now that we've fixed broken timers, handled events that don't trigger change detection, and dealt with third‑party libraries, let's look at some issues related to components that are dynamically created at runtime. In a zoneless OnPush app, simply mutating a dynamically created instance won't re‑render your UI. This means that we need another way to implement reactivity in these cases. Let's look at an example. Here we have a Product Details switcher component. We can navigate to next and previous products in the list to show certain details, but this functionality no longer works since we've switched over to zoneless with OnPush. But notice this here, we've added logging to troubleshoot the issues, and we can see that the product data is actually switching. The UI is just not updating. We can also switch the view here. This is where we're using dynamic components. When switching these views, we dynamically create and inject different components for the two views. And same thing, switching products doesn't update the UI event, though the data is actually updating. Let's look at the code to better understand what we have and what we need to do in order to bring this component back to life. Okay, here on init, we are calling a createView method. Then in this method, based on the selected view type, we are dynamically creating and inserting either the ProductCard or the StockBadgeComponent. Then we are calling the setProductData function. We'll look at this in a sec, but first, here we have a switchView method. This is what gets called when we use the select to switch between product views. We can see that it also calls this createView method. Then we have our previous and next functions that are called when those buttons are clicked. They are supposed to update the data in the dynamic components using the setProductData method, and this method is where the problem exists. Here we're directly mutating the product's field on our dynamically loaded component. This property is not a signal, so in zoneless, change detection isn't triggered. But we know how to fix this, right? Signals. Let's try it. Let's open the product card and switch this property to a signal. Then we just need to update the template now that this is a signal. Okay, let's do the same for the badge component. Let's switch the property to a signal. Then let's update the template. Okay, now the dynamic components are using signals, so we just need to switch the setProductData method over to set the signal instead with the set method. There, let's save and try it out. Okay, it looks good to start. Let's try navigating through the products. Nice. Now it's working like it should, so that's cool, right? But you're probably thinking to yourself, wait. Isn't there another way to do this? Yes, we probably shouldn't use signals directly here, right? We should use inputs and the setInput function instead. Let's switch back over and update to this. In the product card, let's switch to the input function. And then let's do the same in the StockBadgeComponent. Then we just need to switch to the setInput function in the details component. Okay, that's it. Let's save and see if it works. All right, it looks right from the start again, so that's good. Let's navigate through the products. Nice, everything still updates correctly. And then we can switch views and navigate through products perfectly, too. This component is now alive and well in our zoneless setup. So it's important to remember that in zoneless apps, dynamic components won't be refreshed by mutating instances programmatically. Switching to signals will totally work, but it's not exactly the best way to set data in dynamically injected components. Instead, we should use inputs and the setInput function. It was built for this exact scenario. Next up, we'll look at a quick dev‑only tool that flags bindings which change after a check that are often difficult to see in zoneless Angular.

Catching Missed Updates in Development
Now that we've fixed several common change detection issues in zoneless Angular, it's time to look at one last troubleshooting feature. We're going to look at the provideCheckNoChangesConfig. This is a development specific feature used to catch subtle change detection issues that might otherwise be missed. It periodically runs comprehensive checks across the entire component tree to help surface hard‑to‑catch issues. Let's look at an example. Here we're looking at a product toolbar component. Everything looks great, right? And we don't have any console errors either. But there is a subtle issue here. When I hover over these buttons, they are supposed to expose their label text using the title attribute since they don't have a visual label displayed. But these aren't working properly. Let's switch over to the code to better understand the issue. Here we're using property binding to add the title to each button based on the content of the visually hidden label. The issue is that the title is being derived from the DOM, not from state that Angular tracks reactively. In zoneless, that can become a binding changed after it was checked scenario that's hard to see. But luckily, we do have a way to catch these in development with the provideCheckNoChangesConfig. Let's switch over to our application configuration. Here in our provider's array, we need to add provideCheckNoChangesConfig. Then we'll add an exhaustive property and set it to true, which tells it to check all components for changes. And then we can provide the interval for how often we want it to run. The shorter the interval, the greater the impact on performance. Let's go with 1 second. So this check will run every second for us now. Okay, let's save and see how this works now. There, now we get a clear error highlighting that something changed after Angular finished the check. And we can see that it's referencing the line that's causing the error. So, if we switch back to the code for this component, we can see that it's referring to our title binding here. I'm going to fix this issue by moving these labels over to template local values, so the title and the visually hidden text share the same reactive source. There. Now let's save and see if this fixed the issue. Nice. No more error, and when we hover over the buttons, the titles are now properly bound and displaying. Much better. So, in zoneless, we can't really bind from the DOM when we have dynamic properties involved like we saw here. Instead, we need to bind from state. And while these types of issues can be difficult to find, Angular has our back with the provideCheckNoChangesConfig. So now you've seen how Angular's default zone‑based change detection walks the tree and why that can be overeager as apps grow. You learned where the costs show up and why OnPush already helps. We switched to zoneless and removed Zone.js. In doing so, we learned what stops auto‑updating. From here on out, you decide when change detection runs. We then learn to use OnPush to narrow the blast radius, manual change detection for quick fixes and edge cases, and signals to properly update reactively in zoneless apps. So, what now? Well, here are some core concepts to keep in mind as you build going forward. Number one, prefer signals for updates and managing state. They are key in zoneless Angular. Keep using OnPush everywhere that you can. Yes, it matters even in zoneless. Use manual change detection sparingly. Most of the time there's a better way. And in development, consider flipping on provideCheckNoChangesConfig to catch the "looked fine, but wasn't" bugs. You now have the tools and the judgment to ship fast, predictable UIs without Zone.js, build with signals, draw tight boundaries with OnPush, and let Angular do less work while your app stays smooth. Thanks for watching, and good luck as you move on to build in a zoneless future!